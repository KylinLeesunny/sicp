#lang sicp
(define (accumulate op initial l)
  (if (null? l)
      initial
      (op (car l) (accumulate op initial (cdr l)))))
(define (filter predicate? seq)
  (accumulate append nil
       (map
        (lambda (x) (if (predicate? x)
                        (list x)
                        nil))
        seq)
       ))
(define (enumerate-i a b)
  (if (> a b)
      nil
      (cons a (enumerate-i (+ 1 a) b))))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define (queens size)
  (define (queens-cols k)
    (if (= 0 k)
        (list nil)
                (flatmap (lambda(rest-of-queens)
                         (map (lambda (new-position)
                                (cons new-position rest-of-queens))
                              (enumerate-i 1 size)))
                         (queens-cols (- k 1)))))
  (define (safe? position)
    (define (check pos l i)
      (if (null? l)
          #t
          (let ((current (car l)))
            (cond ((or (= pos current)
                    (= (+ pos i) current)
                    (= (- pos i) current)) #f)
                  (else (check pos (cdr l) 0))))))
    (check (car position) (cdr position) 1))
  (queens-cols size))
(display (queens 5))